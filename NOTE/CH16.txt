<Structure variables>
- the elements of a structure (its members) are not required to have the same type
- the members of a structure have names (배열과는 다르게 원소에 접근하려면 위치가 아니라 이름으로 접근해야 한다)

<Declaring structure variables>
- 관련있는 데이터들을 묶음으로 저장할 필요가 있을 때 구조체를 사용한다
- 구조체의 멤버들은 '선언된 순서대로' 메모리에 저장된다
- Each structure represemts a new scope
	- 한 구조체에서 사용된 멤버이름이 다른 구조체에서도 사용될 수 있다
	- C용어로는 각 구조체가 그 멤버들에 대해 별개의 namespace를 가진다고도 표현한다
	
<Initializing structure variable>
- 배열을 초기화할 때처럼 선언 시 {}안에 멤버들을 넣어 초기화할 수 있다. (멤버들은 선언한 순서대로 정렬되어 있어야 한다)
- C89에서는 상수로만 멤버를 초기화할 수 있다 (C99에서는 또 다르다고 하네용)
- 초기화에 쓰인 {} 안에 들어있는 멤버 개수가 구조체 멤버 개수보다 적으면 초기화가 되지 않은 나머지 멤버들은 모든 비트가 0인 데이터로 초기화된다

<Designated Initializer>
- 배열과 비슷한 방식으로 멤버를 특정하여 초기화하는 것이 가능하다
{.number = 528 , .name = "Disk Drive", .on_hand = 10}
- 점과 멤버이름을 조합하여 만드는 designator로 멤버를 특정한다
- designator를 사용하면 초기화하는 멤버 순서가 원래 선언 순서와 달라도 상관 없다
- designator를 사용한 멤버와 사용하지 않은 멤버를 혼합해 사용할 수도 있다. 이 경우 순서는 designator를 사용한 멤버 바로 다음 순서부터 시작하는 것. (배열 원소 초기화 시 규칙과 흡사하다)

<Operation on structures>
- 구조체 멤버의 접근은 구조체_이름.구조체_멤버_이름 과 같이 구조체 이름 뒤에 점을 붙이고 멤버이름을 써서 접근한다
- 구조체 멤버는 lvalue이므로 값의 변경이 가능하다
- 구조체 멤버 앞에 붙는 .은 사실 연산자이다. ++와 같은 precedence를 가지고 있으므로 거의 모든 연산자보다 우선해서 실행된다고 보면 된다

- 배열과는 다르게 구조체는 = 연산이 가능하다
	- part1과 part2라는 구조체가 있으면 part1 = part2; 같은 게 가능하다는 소리다
	- 심지어 배열이 구조체의 멤버면 배열도 전부 복사된다...
	- 대신에 =를 사용할 수 있는 건 두 구조체가 compatiable type일 경우 한정이다
	- 그래도 ==나 != 같은 건 안된다

<Structure types>
- 구조체 타입이 같은 변수를 여러 개 선언하고 싶은데 변수들의 선언 시점을 다르게 하고 싶을 수 있다
- 이 경우 구조체 변수 선언을 여러 번 하면 프로그램이 쓸데없이 길어질 뿐더러 두 변수가 compatiable type이 아니라고 인식되기 때문에 =연산자를 사용할 수가 없다
- 이 문제를 해결하기 위해 구조체 변수의 이름이 아니라 구조체 변수의 타입의 이름을 지정할 필요가 있다
- structure tag 나 typedef를 사용하여 구조체타입이름을 지정할 수 있다

<Declaring a structure tag>
- is a name used to identify a particular kind of structure
- struct 뒤에 struct tag를 붙여서 구조체 이름을 짧게 표현할 수 있다
struct part {
	int member;
	char name[NAME_LEN+1];
	int on_hand;
}; // 세미콜론으로 반드시 마무리를 지어줘야 한다
- 선언 후에 struct part part1; 같은 식으로 struct part라는 타입을 가진 part1 구조체변수를 선언할 수 있다
	- struct를 빼고 part part1; 같은 식으로 선언하는 것은 불가능하다. //struct를 뺀 part는 아무 의미가 없기 때문에 변수 이름을 이걸로 설정해도 된다... 물론 가독성이 망하겠지만
* 구조체 선언과 구조체 변수 선언을 같이 해도 된다. (int를 예로 들면 int a = 7; 이라고 해도 된다는 것과 같은 소리)

<Defining a structure type>
- 구조체 앞에 typedef를 붙이고 뒤에 구조체 이름을 붙여서 구조체의 타입이름을 정의할 수 있다
typedef struct {
	int member;
	char name[NAME_LEN+1];
	int on_hand;
} Part; //Part라는 구조체타입을 선언했다
- Part가 하나의 타입이므로 struct Part는 타입이 아니다
- 연결 리스트에서는 사용할 수 없다고 하네용

<Structures as arguments and return values>
- 구조체를 arguments 나 반환값으로 사용하는 경우 구조체의 모든 멤버의 복사본을 사용하게 되므로 프로그램에 쓸데없는 오버헤드를 강요한다
- 이걸 막기 위해 구조체가 클 경우 구조체의 포인터를 사용하는 경우도 있다
- 같은 구조체 타입을 사용하고 있으면 매개변수로 함수 안의 구조체를 초기화할 수도 있다.

<Compund literals>
- 구조체 변수 이름을 선언하지 않고 바로 사용할 수도 있다
print_part( (struct part) {528, "Disk Drive" , 10} ); //print_part함수에 struct part 타입의 구조체를 전달한다
- designator 도 사용할 수 있다

<Nested arrays and structures>
- structures and arrays can be combined without restriction (구조체의 멤버가 배열이 될 수도 있고 배열의 원소가 구조체가 될 수도 있다)

<Nested structures>
- 구조체의 멤버로 구조체 변수를 둘 수 있다
- 이 경우 관련있는 멤버들을 묶어 한 번에 관리하므로 함수에 전달할 때나 값을 할당할 때 적은 줄의 코드가 필요하다는 장점이 있다.

<Arrays of structures>
- 구조체로 이루어진 배열
- 구조체가 배열의 원소이기 때문에 []를 이용한 subscripting으로 접근하고 다시 .으로 구조체의 멤버에 접근할 수 있다
inventory[i].number = 3; //inventory라는 구조체 배열의 i번째 구조체 변수의 number 멤버의 값을 3으로 변경

<Initializing an array of structures>
- 구조체배열의 초기화는 다차원 배열의 초기화와 비슷하다
- 각 구조체를 {}로 감싼 멤버들의 집합으로 표현한다
- 구조체 자체에 대한 designator와 구조체의 멤버에 대한 designator를 혼용해서 사용해도 된다
struct part inventory[100] = 
	{[0].number = 528, [0].on_hand = 10, [0].name[0] = '\0'}; //마지막에 가서는 배열에서의 위치, 구조체에서 name, name에서의 위치 를 나타내기 위해 3개의 designators를 사용했다 


