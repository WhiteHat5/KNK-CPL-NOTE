<Pointers and arrays>
- 포인터가 배열의 원소를 가리키고 있으면 덧셈 뺄셈이 가능하다
- 배열을 다룰 때 포인터를 다루는 게 옛날에는 효율적이었지만 요즘에는 컴파일러가 발전해서 비슷비슷하다고 하네용

<Pointer Arithmetic>
- C supports 3 forms of pointer arithmetic
	- Adding an integer to a pointer
	- Subtracting an integer from a pointer
	- Subtracting one pointer from another

<Adding an integer to a pointer>
- if p points to the array element a[i], p+j points to a[i+j]
- 포인터에 정수 j를 더하면 원래 자리에서 j만큼 뒤에 있는 원소를 가리키게 된다

<Subtracting an integer from a pointer>
- if p points to the array element a[i], then p-j points to a[i-j]

<Subtracting one pointer from another>
- 한 포인터에서 다른 포인터를 뺀 결과는 두 포인터가 가리키는 원소 사이의 거리이다(거리는 원소의 메모리상 크기를 단위로 측정된다)
* 포인터가 배열의 원소를 가리키고 있지 않은 경우, 두 포인터가 가리키는 배열이 다른 경우 결과를 예측할 수 없다

<Comparing pointers>
- 같은 배열의 원소를 가리키는 포인터끼리의 비교만 의미있다
- 배열의 뒤쪽에 위치한 원소를 가리키는 포인터가 크다고 판단한다

<Pointers to compound literal>
- compound literal로 이름없는 배열을 만들 수 있다
int *p = (int[]){3 ,0 ,3 ,4 ,1}; //p는 5개의 원소로 이루어진 배열 중 첫번째 원소를 가리키게 된다(배열을 먼저 선언하고 포인터가 배열을 가리키게 하는 작업을 없애준다)

<Using pointers for array processing>
- 포인터에 정수를 더하고 빼는 것으로 배열의 원소에 접근할 수 있다는 점을 이용하여 반복문에 활용할 수 있다 (예를 들면 포인터에 1씩 더하면서 모든 배열의 원소에 접근하는 식이다)
- 실행시간을 아끼기 위해 사용되지만 컴파일러에 따라 더 느려지는 경우도 있다고 하네용

<Combining the * and ++ operators>
- ++연산자가 *연산자보다 먼저 실행된다
- *p++ 는 *(p++) 와 같다 (p 자체가 증가한다) //반복문에서 많이 쓴다고 함
- (*p)++ (p가 가리키고 있는 값이 증가한다)
- *++p 는 *(++p) 와 같다 (p 자체가 증가한다)
- ++*p 는 ++(*p) 와 같다 (p가 가리키는 값이 증가한다)

<Using an array name as a pointer>
- the name of an array can be used as a pointer to the first element in the array
- 배열 이름도 포인터처럼 *연산자를 이용해 값에 접근할 수 있다
- 배열의 이름이 포인터처럼 쓰이긴 하지만 배열 이름의 값을 바꾸는 것은 불가능하다 (덧셈 등의 연산을 통해 원소 값에 접근하는 것은 가능하다)

