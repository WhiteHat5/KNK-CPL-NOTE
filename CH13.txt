STRINGS

<String literals>
- is a sequence of characters enclosed within double quotes

<Escape Sequences in string literals>
- String 안에 escape sequence를 넣을 수 있다
* octal escape sequence는 3자리수를 넘어가거나 8진법 숫자가 아닌 수가 나오면 종료된다 (\038의 경우 \03과 8로 인식된다)
** hexadecimal escape sequence 는 자리수의 제한이 없으며 hexadecimal이 아닌 값이 나올 때까지 계속된다 (compiler마다 ff를 넘어가는 값을 무시하는 경우도 있다)

<Continuing a String literal>
- 코드 내에서 \(백슬래시) 이후 줄바꿈을 하는 것으로 string을 이어 쓸 수 있다 (여러 줄에 걸쳐 쓸 수 있다) 
	이걸 splicing이라고 한다네용
	* splicing을 하는 경우 string이 바로 다음 줄에서 시작해야 한다 (indenting을 할 수 없다)
- when two or more string literals are adjacent (seperated only by white space), the compiler will join them into a single string

<How string literals are stored>
- C treats string literals as an argument
- 길이가 n인 string literal을 만나면  n+1 바이트의 메모리 공간을 확보한다
	- 하나 남는 자리는 null character가 차지한다 (string의 끝을 나타낸다)
	- null character의 바이트는 모든 비트가 0이며 \0으로 표현 가능하다
- string literal은 배열에 저장되기 때문에 컴파일러는  char * 타입의 포인터로 인식한다

<Operations on string literals>
- C는 string literal을 char * 타입의 포인터로 인식하기 때문에 포인터가 쓰이는 곳에는 다 쓸 수 있다
	- char *p; 일 때 p에 "abc"를 할당할 수 있다
	- "abc"[1] 로 b를 나타낼 수 있다 (배열 이름처럼 사용가능하다)
- string literal은 수정할 수 없다 (배열처럼 원소를 바꾸려고 하면 오류가 난다)

<String literals versus character constants>
- "a"는 포인터이고 'a'는 정수다
- string literal의 경우 문자열이 들어있는 장소를 가리키는 포인터이고 문자상수는 아스키코드표에 따라 문자를 나타내는 정수이다

<String variables>
- char 타입의 1차원 배열은 string을 저장하는 데 사용될 수 있다 (null character로 잘 종료시키기만 하면)
- 이 경우 string의 길이를 아는 가장 빠른 방법은 문자를 하나하나 검색해서 null character를 찾는 방법 뿐이다
	* string을 저장할 배열을 선언하는 경우 원하는 길이보다 1개 길게 만들라고 하네용 (null character를 저장할 공간을 확보하기 위해서이다)

<Initializing a string variable>
- char 배열을 초기화할 때 string literal을 사용해서 초기화 할 수 있다
	- 배열의 길이가 string보다 길 경우 남은 공간을 null character로 채운다
	- 배열의 길이가 string보다 짧을 경우 초기화를 할 수 없다
	! 그런데 만약 배열의 길이가 null character를 제외한 문자열의 길이와 같다면 null character를 제외한 나머지 문자만 저장된다 (이 경우 string으로 인식되지 않으므로 주의!)
	- 배열의 길이가 주어지지 않으면 컴파일러가 자동으로 배열의 길이를 문자열의 길이와 같게 설정한다 (이 경우 직접 길이를 정하는 것보다 좋을 수도 있는 게 긴 문자열의 경우 일일히 문자 개수 세는 게 정확할 리가 없기 때문)
	
<Character arrays versus Character pointers>
char date[] = "June 14"; //date가 배열인 경우
char *date = "June 14"; // date가 포인터인 경우
- 배열의 경우 date라는 배열에 문자들이 저장된 것이므로 원소(문자)들의 수정이 가능하다
- 포인터의 경우 포인터가 string literal을 가리키고 있는 것이므로 문자들의 수정이 불가능하다
- 배열의 경우 date가 배열 이름이지만 포인터의 경우 date는 string을 가리키고 있는 변수이므로 다른 string을 가리키게 할 수도 있다
* 포인터 p가 가리키는 string을 변경할 수 있게 하고 싶으면 새로운 배열을 선언해서 값을 복사하거나 dynamically allocated string을 이용하라고 한다

<Reading and writing strings>
- string의 출력은 쉽다. printf 나 puts 로 그냥 출력하면 되니까
- 입력은 더 어렵다. 주로 입력할 string의 길이가 값을 저장할 배열보다 길 가능성 때문에 문제가 생긴다. string을 한 번에 읽을 때는 scanf나 gets를 보통 쓰고 문자 하나씩 읽는 방법도 있다

<Writing strings using printf and puts>
- %s conversion specification allows printf to write a string
- printf는 null character를 찾을 때까지 string을 읽으며 모든 문자를 출력한다
- %m.ps (p는 출력할 문자의 개수를 의미한다)(m은 최소 출력 문자를 의미하고 문자열이 m보다 짧으면 오른쪽에 붙어서 나온다) (-를 붙여서 왼쪽에 붙어 나오게 할 수 있다)
- puts(str) 은 전달인자로 받은 string을 출력하며 string을 출력한 후 줄바꿈 문자를 출력한다 (항상 다음줄로 넘어간다)

<Reading strings using scanf and gets>


